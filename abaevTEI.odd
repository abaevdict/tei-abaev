<?xml version="1.0"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en" xmlns:abv="http://ossetic-studies.org/ns/abaevdict" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:rng="http://relaxng.org/ns/structure/1.0"><teiHeader><fileDesc><titleStmt><title>TEI for Abaev</title><author>generated by Roma 5.0.1</author></titleStmt>
    <publicationStmt>
        <p>for use by whoever wants it</p>
    </publicationStmt><notesStmt><note type="ns">http://ossetic-studies.org/ns/abaevdict</note></notesStmt><sourceDesc><p>created on Wednesday 06th January 2021 01:42:50 PM</p></sourceDesc></fileDesc></teiHeader><text><front><divGen type="toc"/></front><body><p>My TEI Customization&#xD;
        starts with modules tei, core, textstructure and header</p>
            <schemaSpec ident="abaevTEI" docLang="en" prefix="tei_" xml:lang="en" defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML http://ossetic-studies.org/ns/abaevdict">
                <moduleRef key="core" except=""/>
                <moduleRef key="tei" except=""/>
                <classSpec module="tei" type="atts" ident="att.global.responsibility" mode="change">
                    <attList>
                        <attDef ident="cert" mode="delete"/>
                        <attDef ident="resp" mode="delete"/>
                    </attList>
                </classSpec>
                <classSpec module="tei" type="atts" ident="att.datcat" mode="change">
                    <attList>
                        <attDef ident="datcat" mode="delete"/>
                        <attDef ident="valueDatcat" mode="delete"/>
                    </attList>
                </classSpec>                
                <moduleRef key="header" except=""/>
                <moduleRef key="textstructure" except=""/>
                <moduleRef key="dictionaries" except=""/>
                <classSpec module="dictionaries" type="atts" ident="att.lexicographic" mode="change">
                    <attList>
<!--                        <attDef ident="expand" mode="delete"/>-->
                        <attDef ident="split" mode="delete"/>
                        <attDef ident="value" mode="delete"/>
                        <attDef ident="location" mode="delete"/>
                        <attDef ident="mergedIn" mode="delete"/>
                        <attDef ident="opt" mode="delete"/>
                    </attList>
                </classSpec>                
                <moduleRef key="figures" except="notatedMusic"/>
                <moduleRef key="linking"/>
                <classSpec module="linking" type="atts" ident="att.global.linking" mode="change">
                    <attList>
                        <attDef ident="synch" mode="delete"/>
                        <!--<attDef ident="sameAs" mode="delete"/>-->
                        <attDef ident="copyOf" mode="delete"/>
                        <attDef ident="next" mode="delete"/>
                        <attDef ident="prev" mode="delete"/>
                        <attDef ident="exclude" mode="delete"/>
                        <attDef ident="select" mode="delete"/>
                    </attList>
                </classSpec>
                <moduleRef key="analysis" include="w m c cl phr s pc"/>
                <classSpec module="analysis" type="atts" ident="att.global.analytic" mode="change">
                    <attList>
                        <attDef ident="ana" mode="delete"/>
                    </attList>
                </classSpec>
                
<!--                <moduleRef key="certainty"/>-->
                <classSpec module="tei" type="atts" ident="att.global" mode="change">
                    <classes mode="change">
                        <!--<memberOf mode="delete" key="att.global.linking"/>-->
                        <memberOf mode="delete" key="att.global.rendition"/>
                    </classes>
                    <constraintSpec ident="lang-not-empty" scheme="schematron">
                        <constraint><sch:rule context="@xml:lang">
                                <sch:assert test="string(.) != ''" role="warning">Language may not be empty.</sch:assert>
                            </sch:rule></constraint>
                    </constraintSpec>
                    <attList>
                        <attDef ident="xml:space" mode="delete"/>                        
                    </attList>
                </classSpec>
                
                <classSpec type="atts" ident="att.dialectal" mode="add">
                    <desc>provides an attribute that defines the dialect of the element, in addition
                        to <att>xml:lang</att>.</desc>
                    <attList>
                        <attDef ident="dialect" mode="add">
                            <datatype minOccurs="1" maxOccurs="unbounded">
                                <dataRef name="language"/>
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p>Mainly applies to <gi>mentioned</gi> words in etymologies.</p>
                    </remarks>
                </classSpec>
                
                <classSpec type="atts" ident="att.extralang" mode="add">
                    <desc>provides an attribute that specifies languages of the element in addition
                        to <att>xml:lang</att>, if more than one is specified in the source.</desc>
                    <attList>
                        <attDef ident="extralang" mode="add">
                            <datatype minOccurs="1" maxOccurs="unbounded">
                                <dataRef name="language"/>
                            </datatype>
                        </attDef>
                    </attList>   
                    <remarks>
                        <p>Mainly applies to <gi>mentioned</gi> words in etymologies.</p>
                    </remarks>                    
                </classSpec>
                
                <classSpec type="atts" ident="att.sortable" mode="delete"/>
                <classSpec type="atts" ident="att.global.source" mode="delete"/>
                <classSpec type="atts" ident="att.global.rendition" mode="change">
                    <attList>
<!--                        <attDef ident="rendition" mode="delete"/>-->
                        <attDef ident="style" mode="delete"/>
                    </attList>
                </classSpec>
                <classSpec type="atts" ident="att.global.linking" mode="change">
                    <attList>
                        <attDef ident="synch" mode="delete"/>
                        <attDef ident="sameAs" mode="delete"/>
                        <attDef ident="copyOf" mode="delete"/>
                        <attDef ident="next" mode="delete"/>
                        <attDef ident="prev" mode="delete"/>
                        <attDef ident="exclude" mode="delete"/>
                        <attDef ident="select" mode="delete"/>
                    </attList>
                </classSpec>
                
                <classSpec type="atts" ident="att.lexicographic">
                    <classes mode="change">
                        <memberOf mode="delete" key="att.lexicographic.normalized"/>
                    </classes>
                </classSpec>
                
                <classSpec type="atts" ident="att.linguistic" mode="change">
                    <classes mode="change">
                        <memberOf mode="delete" key="att.lexicographic.normalized"/>
                    </classes>
                </classSpec>
                
                <classSpec type="atts" ident="att.partials" mode="delete"/>
                <classSpec type="atts" ident="att.notated" mode="delete"/>
                
                <elementSpec ident="note" mode="change">
                    <attList>
                        <attDef ident="type" mode="change" usage="req">
                            <valList mode="replace" type="closed">
                                <valItem ident="comment"><gloss>comments to various elements of the dictionary, usually in parentheses or separated from their environment by other punctuation; these punctuation marks should be included within the note, if possible</gloss></valItem>
                                <valItem ident="internal"><gloss>comments for internal use of project participants, not intended for publication</gloss></valItem>
                                <valItem ident="footnote"/>
                                <valItem ident="bibl"><gloss>bibliographic note, mainly used in <gi>re</gi>, which sometimes includes bibliographic citations (because <gi>bibl</gi> cannot be inserted directly).</gloss></valItem>
                            </valList>
                        </attDef>
                        <attDef ident="xml:lang" mode="change" usage="rec">
                            <xi:include href="vallist-ruen.xml" parse="xml"/>
                        </attDef>
                    </attList>
                </elementSpec>
                
                <elementSpec module="core" ident="hi" mode="change">
                    <classes mode="change">
                        <memberOf mode="add" key="att.global.rendition"/>
                    </classes>
                </elementSpec>
                
                <elementSpec module="core" ident="q" mode="change">
                    <classes mode="change">
                        <memberOf mode="add" key="att.global.rendition"/>
                    </classes>
<!--                    <content>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                            <textNode/>
                            <classRef key="model.gLike"/>
                            <classRef key="model.global"/>
                            <classRef key="model.hiLike"/>
                            <classRef key="model.emphLike"/>
                            <classRef key="model.ptrLike.form"/>
                            <classRef key="model.ptrLike"/>
                        </alternate>
                    </content>      -->              
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="entry" mode="change">
                    <classes mode="change">
                        <memberOf mode="delete" key="att.typed"/>
                    </classes>
                    <content>
                        <sequence>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="form" minOccurs="1" maxOccurs="2"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms -->
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="usg" minOccurs="0" maxOccurs="1"/>
                            <alternate minOccurs="0" maxOccurs="unbounded">
                                <classRef key="model.global"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms after the sense -->                                
                                <elementRef key="sense"/>
                                <elementRef key="re"/>                                
                            </alternate>
<!--                            <alternate minOccurs="0" maxOccurs="unbounded">
                                <classRef key="model.global"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-\- additional forms after the sense -\->                                
                                <elementRef key="re"/>
                            </alternate>-->
                            <alternate minOccurs="0" maxOccurs="unbounded">
                                <classRef key="model.global"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms after the sense -->
                                <elementRef key="exampleGrp"/>
                            </alternate>
                            <alternate minOccurs="0" maxOccurs="unbounded">
                                <classRef key="model.global"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms after the sense -->
                                <elementRef key="re"/>
                            </alternate>
                            <alternate minOccurs="0" maxOccurs="unbounded">
                                <classRef key="model.global"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms after the sense -->
                                <elementRef key="exampleGrp"/>
                            </alternate>
                            <!--<classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
                            <elementRef key="etym" minOccurs="0" maxOccurs="2"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="ref" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                    </content>
                    <constraintSpec ident="form-type" scheme="schematron">
                        <constraint xmlns:abv="http://ossetic-studies.org/ns/abaevdict">
                            <sch:rule context="tei:entry/tei:form[1]">
                                <sch:assert test="@type = 'lemma'">The first form must have the type
                                    'lemma' (headword).</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:entry/tei:form[2]">
                                <sch:assert test="@xml:lang = 'os-x-digor'">The second form may only
                                    be the Digor form.</sch:assert>
                                <sch:assert test="@type = 'dialectal'">The second form must be a
                                    dialectal variant.</sch:assert>
                            </sch:rule>
                            <sch:rule context="formGrp/tei:form[2]">
                                <sch:assert test="@xml:lang = 'os-x-digor'">The second form may only
                                    be the Digor form.</sch:assert>
                                <sch:assert test="@type = 'dialectal'">The second form must be a
                                    dialectal variant.</sch:assert>
                            </sch:rule>                            
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="note-type" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:entry/tei:note[@type = 'internal']">
                                <sch:assert test="not(following-sibling::tei:etym)">Internal note
                                    should follow etymology.</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:entry/tei:note[@type = 'comment']">
                                <sch:assert test="not(preceding-sibling::tei:etym)">Entry comments
                                    should precede etymology.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
<!--                    <constraintSpec ident="cit-type" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:entry/tei:cit">
                                <sch:assert test="@type = 'exampleGroup'">A 'cit' element inside
                                    'entry' should be of type 'exampleGroup'.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>-->
                    
                    <attList>
                        <attDef ident="xml:lang" mode="change" usage="req">
                            <xi:include href="vallist-oslang.xml"/>
                        </attDef>
<!--                        <attDef ident="corresp" mode="delete"/>-->
                        <attDef ident="status" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                            <valList mode="replace" type="closed">
                                <valItem ident="new"><gloss>New entry not found in Abaev's original dictionary.</gloss></valItem>
                            </valList>
                        </attDef>
                        <attDef ident="completeness" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                            <valList mode="replace" type="closed">
                                <valItem ident="incomplete"><gloss>Entry requires additional work on annotation and/or translation.</gloss></valItem>
                                <valItem ident="questions"><gloss>Entry essentially complete but questions remain.</gloss></valItem>
                                <valItem ident="russian-questions"><gloss>Entry essentially complete but questions in the Russian translation remain.</gloss></valItem>
                                <valItem ident="english-questions"><gloss>Entry essentially complete but questions in the English translation remain.</gloss></valItem>
                                <valItem ident="complete"><gloss>Entry is finished.</gloss></valItem>
                            </valList>
                        </attDef>                        
                    </attList>
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="sense" mode="change">
                    <content>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                            <!--<macroRef key="macro.xtext"/>-->
                            <elementRef key="sense"/>
                            <elementRef key="def"/>
                            <elementRef key="tr"/>
                            <elementRef key="usg" minOccurs="0" maxOccurs="2"/>
                            <elementRef key="re"/> <!-- cf. lasyn -->
                            <elementRef key="example"/>
                            <classRef key="model.global"/>
                        </alternate>
                    </content>
                    <attList>
                        <attDef ident="xml:lang" mode="change">
                            <xi:include href="vallist-oslang.xml"/>
                        </attDef>
                    </attList>
                    <remarks>
                        <p>The content model of the <gi>sense</gi> element is strongly restricted
                            compared to standard TEI: it may only contain character data, subsenses,
                            translations, usage notes (to indicate language / dialect, where
                            applicable) and global elements such as notes.</p>
                    </remarks>
                </elementSpec>
                
                <!--        <elementSpec module="linking" ident="seg" mode="change">
            <attList>
                <attDef ident="type" mode="change" usage="req">
                    <valList type="closed" mode="replace">
                        <valItem ident="exGrp"><gloss>Example group</gloss></valItem>
                    </valList>
                </attDef>
            </attList>
        </elementSpec>-->
                
                <!--        <elementSpec module="dictionaries" ident="lang" mode="change">
            <attList>
                <attDef ident="xml:lang" mode="change" usage="req">
                    <valList type="closed" mode="replace">
                        <valItem ident="ru"><gloss>рус. / Russian</gloss></valItem>
                        <valItem ident="en"><gloss>англ. / English</gloss></valItem>
                    </valList>
                </attDef>
            </attList>            
        </elementSpec>  -->
                
                <elementSpec module="dictionaries" ident="form" mode="change">
                    <attList>
                        <attDef ident="n" mode="delete"/>
                        <attDef ident="type" usage="req" mode="change">
                            <valList mode="replace" type="closed">
                                <valItem ident="lemma"/>
                                <valItem ident="dialectal"/>
                                <valItem ident="participle"/>
                                <valItem ident="variant"/>
                                <valItem ident="synonym"/>
                                <valItem ident="plural"/>
                            </valList>
                        </attDef>
                        <attDef ident="subtype" usage="opt" mode="change">
                            <valList mode="replace" type="closed">
                                <valItem ident="parens"/>
                            </valList>
                        </attDef>
                    </attList>
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="orth" mode="change">
                    <classes mode="change">
                        <memberOf mode="delete" key="att.typed"/>
                    </classes>
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="formGrp" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                    <desc xml:lang="en">a set of additional forms; corresponds to a <gi>cit</gi> element with <att>type</att> = <val>form</val>.</desc>
                    <classes>
                        <memberOf key="att.global"/>
                        <memberOf key="att.global.rendition"/>
<!--                        <memberOf key="att.global.linking"/>-->
<!--                        <memberOf key="att.dialectal"/>-->
                        <memberOf key="model.quoteLike"/>
                    </classes>
                    <content>
                        <sequence>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="form" minOccurs="1" maxOccurs="2"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="example" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                    </content>                    
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="example" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                    <desc xml:lang="en">represents an example in Abaev's Ossetic
                        dictionary entry.</desc>
                    <equiv filter="example-filter.xsl" mimeType="text/xsl" name="example"/>
                    <classes>
                        <memberOf key="att.global"/>
                        <memberOf key="att.global.rendition"/>
<!--                        <memberOf key="att.global.linking"/>-->
<!--                        <memberOf key="att.dialectal"/>-->
                        <memberOf key="model.quoteLike"/>
                    </classes>
                    <content>
                        <sequence>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="usg" minOccurs="0" maxOccurs="1"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="quote" minOccurs="1" maxOccurs="1"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="tr" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="bibl" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                    </content>
                    <attList>
                        <attDef ident="xml:lang" usage="opt" mode="change">
                            <desc>the language should only be indicated if the source has <q>д.</q>
                                (for Digor) or <q>ксан.</q> (for Ksan) preceding the example text.
                                Other dialect options are possible, but not attesed. Another, relatively 
                                infrequent case is when the example is in Russian (i.e. there is no
                                Ossetic text). Otherwise <att>xml:lang</att> is inherited from the dictionary
                                entry.</desc>
                            <xi:include href="vallist-example.xml"/>
                        </attDef>
<!--                        <attDef ident="dialect" usage="opt" mode="change">
                            <desc>represents the (sub)dialect of Ossetic used in the example. At
                                this stage, only Ksan has been attested, but other variants cannot
                                be excluded.</desc>
                            <valList mode="replace" type="semi">
                                <valItem ident="os-x-ksan"><gloss>Ksan Iron Ossetic</gloss></valItem>
                            </valList>
                        </attDef>-->
                    </attList>
                    <remarks xml:lang="en">
                        <p>The <gi>example</gi> element is semantically equivalent to the standard TEI
                            element <gi>cit</gi> with the attribute <att>type</att> having the value
                            <val>example</val>.</p>
                    </remarks>
                    <remarks xml:lang="en">
                        <p>The content model is stricter than that of the standard <gi>cit</gi> and
                            includes only those elements that form part of Abaev's dictionary
                            structure: the language/dialect name (embedded in the <gi>usg</gi>
                            element to conform with TEI) the example text (<gi>quote</gi>),
                            translation (<gi>tr</gi>) and bibliographic reference to the source
                                (<gi>bibl</gi>). Of these, only the example text is obligatory,
                            although usually all three elements occur. Global elements (such as
                                <gi>note</gi>) may also appear in any position.</p>
                    </remarks>             
                    <remarks xml:lang="en">
                        <p>Examples do not appear in lexical entries on their own. They must be
                            embedded in an <gi>exampleGrp</gi> element.</p>
                    </remarks>
                    <remarks xml:lang="en">
                        <p>In the source text, examples are separated from each other by semicolons,
                            while example groups are separated by period and dash combinations. This
                            punctuation is added automatically in the electronic dictionary and
                            should not be annotated.</p>
                    </remarks>
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="exampleGrp" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                    <desc xml:lang="en">(example group) represents a group of examples in Abaev's Ossetic
                        dictionary entry.</desc>
                    <equiv filter="examplegrp-filter.xsl" mimeType="text/xsl" name="example"/>
                    <classes>
                        <memberOf key="att.global"/>
                        <memberOf key="att.global.rendition"/>
<!--                        <memberOf key="att.global.linking"/>-->
                        <memberOf key="model.entryPart.top"/>
                    </classes>
                    <content>
                        <sequence>
                            <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="example" minOccurs="1" maxOccurs="unbounded"/>
                            <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                    </content>
                    <attList>
                        <attDef ident="n" mode="change">
                            <desc xml:lang="en">represents the number that precedes the example group in some lexical entries. This number usually corresponds to a numbered <gi>sense</gi>.</desc>
                        </attDef>
                    </attList>
                    <remarks xml:lang="en">
                        <p>This element is a container for <gi>example</gi> elements. It may only
                            include <gi>example</gi> and <gi>note</gi> elements (if the note
                            pertains to the group as a whole and not to a particular example).</p>
                    </remarks>
                    <remarks xml:lang="en">
                        <p>In standard TEI, the semantic equivalent is <gi>cit</gi> with the value
                                <val>exampleGroup</val> for <att>type</att>.</p>
                    </remarks>
                </elementSpec>
                
                <elementSpec module="dictionaries" ident="tr" mode="add" ns="http://ossetic-studies.org/ns/abaevdict">
                    <desc xml:lang="en">(<gloss>translation</gloss>) represents translations of examples in Abaev's dictionary entries.</desc>
                    <equiv filter="tr-filter.xsl" mimeType="text/xsl" name="example"/>
                    <classes>
                        <memberOf key="att.global"/>
                        <memberOf key="att.global.rendition"/>
                        <!-- No model membership, because translations only occur in examples, where they 
                            are explicitly mentioned in the content model. -->
                    </classes>
                    <content>
                        <sequence>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="q" minOccurs="1" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                    </content>
                    <attList>
                        <attDef ident="xml:lang" mode="change" usage="req">
                            <xi:include href="vallist-ruen.xml"/>
                        </attDef>
                    </attList>
                    <remarks xml:lang="en">
                        <p>This element may only contain notes and the example text, which always occurs in quotation marks (<gi>q</gi>).</p>
                        <p>An <att>xml:lang</att> attribute <hi rend="bold">must</hi> be supplied, with the value of either <val>ru</val> or <val>en</val>.</p>
                        <p>In standard TEI, the semantic equivalent is <gi>cit</gi> with the value <val>translation</val> for <att>type</att>.</p>
                    </remarks>
                </elementSpec>      
                
                <elementSpec ident="def" mode="change">
                    <attList>
                        <attDef ident="xml:lang" mode="change" usage="req">
                            <xi:include href="vallist-ruen.xml"/>
                        </attDef>
                    </attList>
                </elementSpec>
                
<!--                Move this to a separate ODD file (for a 'standard compliant' TEI style). cit is not needed in this version.-->
                
                <!--<elementSpec module="core" ident="cit" mode="change">
                    <classes mode="change">
                        <memberOf key="att.global.linking"/>
                    </classes>
                    <constraintSpec ident="tr-ru-eng" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:cit[@type = 'translation']">
                                <sch:assert test="(@xml:lang = 'ru') or (@xml:lang = 'en')"
                                    >Translation must be in Russian (xml:lang = ru) or English
                                    (xml:lang = en).</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <attList>                  
                        <attDef ident="type" mode="replace" usage="req">
                            <valList type="closed" mode="replace">
                                <valItem ident="translation">
                                    <desc xml:lang="en">Translation of a usage example of a lexeme
                                        or word form.</desc>
                                    <desc xml:lang="ru">Перевод примера употребления лексемы или
                                        формы.</desc>
                                </valItem>
                                <valItem ident="example">
                                    <desc xml:lang="en">Example of the usage of an
                                        expression.</desc>
                                    <desc xml:lang="ru">Пример употребления выражения.</desc>
                                </valItem>
                                <valItem ident="exampleGroup">
                                    <desc xml:lang="en">Group of examples in a dictionary
                                        entry.</desc>
                                    <desc xml:lang="ru">Группа примеров в словарной статье.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                    </attList>
                </elementSpec>-->
                
                <elementSpec ident="etym" mode="change">
                    <content><!-- replicates standard TEI P5 but adds example -->
                        <alternate minOccurs="0" maxOccurs="unbounded">
                            <textNode/>
                            <classRef key="model.gLike"/>
                            <classRef key="model.global"/>
                            <classRef key="model.inter"/>
                            <classRef key="model.phrase"/>
                            <elementRef key="def"/>
                            <elementRef key="etym"/>
                            <elementRef key="gramGrp"/>
                            <elementRef key="lbl"/>
                            <elementRef key="usg"/>
                            <elementRef key="xr"/>
                            <elementRef key="example"/>
                        </alternate>
                    </content>
                    <attList>
                        <attDef ident="xml:lang" mode="change" usage="req">
                            <xi:include href="vallist-ruen.xml"/>
                        </attDef>
                    </attList>
                </elementSpec>
                
                <elementSpec ident="mentioned" module="core" mode="change">
                    <classes mode="change">
                        <memberOf key="att.dialectal"/>
                        <memberOf key="att.extralang"/>
                        <memberOf key="att.global.responsibility"/>
<!--                        <memberOf key="att.manylangs"/>-->
                    </classes>
                    <content>
                        <sequence>
                            <elementRef key="lang" minOccurs="0" maxOccurs="1"/>
                            <alternate minOccurs="1" maxOccurs="1">
                                <sequence>
                                    <alternate minOccurs="1" maxOccurs="unbounded">
                                        <classRef key="model.global"/>
                                        <elementRef key="mentioned"/>
                                        <textNode/>
                                        <classRef key="model.gLike"/>
                                    </alternate>
                                    <alternate minOccurs="1" maxOccurs="unbounded">
                                        <classRef key="model.global"/>
                                        <elementRef key="gloss"/>
                                        <textNode/>
                                        <classRef key="model.gLike"/>
                                    </alternate>
                                </sequence>
                                <alternate minOccurs="0" maxOccurs="unbounded">
                                    <classRef key="model.global"/>
                                    <elementRef key="w"/>
                                    <elementRef key="c"/>
                                    <elementRef key="m"/>
                                    <elementRef key="phr"/>
                                    <elementRef key="s"/>
                                    <elementRef key="gloss"/>
                                    <textNode/>
                                    <classRef key="model.gLike"/>
                                </alternate>
                            </alternate>
                        </sequence>
                    </content>
                    <!--<constraintSpec ident="punctuation-only" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:mentioned/text()">
                                <sch:report test="matches(.,'[^ ,—;:()\n]')">Text in mentioned forms must only include punctuation (spaces, commas).</sch:report>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>-->
                    <constraintSpec ident="top-lang" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:mentioned[not(tei:mentioned)]">
                                <sch:assert test="@xml:lang">Mentioned forms must include language attributes.</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:mentioned[tei:mentioned]">
                                <sch:assert test="not(@xml:lang)">Mentioned containers must not define languages.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <attList>
                        <attDef mode="add" ident="mentionedType" usage="rec" ns="http://ossetic-studies.org/ns/abaevdict">
                            <valList type="closed">
                                <valItem ident="proto">
                                    <gloss>proto-form</gloss>
                                    <desc>used for Proto-Indo-European, Proto-Iranian etc. forms from which the entry is described as being derived</desc>
                                </valItem>
                                <valItem ident="cogn">
                                    <gloss>cognate</gloss>
                                    <desc>words defined as cognates</desc>
                                </valItem>
                                <valItem ident="loan-to">
                                    <gloss>loan into Ossetic</gloss>
                                    <desc>words borrowed into Ossetic</desc>
                                </valItem>
                                <valItem ident="loan-from">
                                    <gloss>loan from Ossetic</gloss>
                                    <desc>words borrowed from Ossetic</desc>
                                </valItem>
                                <valItem ident="info">
                                    <gloss>general information</gloss>
                                    <desc>typological comparisons, etc.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                        <attDef ident="xml:lang" mode="change" usage="rec"/>
                    </attList>
                </elementSpec>
                
                <elementSpec ident="gloss" mode="change">
                    <classes mode="change">
                        <memberOf key="att.extralang"/>
                    </classes>
                </elementSpec>
                
                <elementSpec module="core" ident="ref" mode="change">
                    <!--<constraintSpec ident="crossref-id" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:ref[@type='xr']">
                                <sch:assert test="substring(@target,2) = //tei:entry/@xml:id">The cross-referenced entry <sch:value-of select="substring(@target,2)"/> does not exist.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>-->  
                    <constraintSpec ident="target-or-text" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:ref">
                                <sch:assert test="text() | @target" role="warning">Bibliographic reference must either point to a known bibliography item or include explicit text.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>                    
                    <attList>
                        <attDef ident="type" mode="change" usage="req">
                            <valList mode="replace" type="closed">
                                <valItem ident="xr"/>
                                <valItem ident="bibl"/>
                                <valItem ident="url"/>
                            </valList>
                        </attDef>
                        <attDef ident="target" usage="rec" mode="change"/>
                    </attList>
                </elementSpec>
                
                
                <!--        <elementSpec module="core" ident="bibl" mode="change">
            <attList>
                <attDef ident="corresp" mode="change">
                    <valList type="semi" mode="replace">
                        <valItem ident="src_AK"/>
                        <valItem ident="src_Аргъ."/>
                        <valItem ident="src_Arsen"/>
                        <valItem ident="src_Æfx. Xæs."/>
                        <valItem ident="src_Ӕмб."/>
                        <valItem ident="src_Bar."/>
                        <valItem ident="src_Bes."/>
                        <valItem ident="src_Bes. Ka ke"/>
                        <valItem ident="src_Брит."/>
                        <valItem ident="src_Čerm."/>
                        <valItem ident="src_Christ."/>
                        <valItem ident="src_Comaq"/>
                        <valItem ident="src_Диг. сказ."/>
                        <valItem ident="src_F."/>
                        <valItem ident="src_FS"/>
                        <valItem ident="src_Gurdž. Æduli"/>
                        <valItem ident="src_Gurdž. Saxi ræs."/>
                        <valItem ident="src_Gurdž. Wadž."/>
                        <valItem ident="src_Iræf"/>
                        <valItem ident="src_Kæfq."/>
                        <valItem ident="src_Коста"/>
                        <valItem ident="src_LQ"/>
                        <valItem ident="src_MD"/>
                        <valItem ident="src_MSt."/>
                        <valItem ident="src_%sMunk.%s"/>
                        <valItem ident="src_Нарт. сказ."/>
                        <valItem ident="src_%sNiger%s"/>
                        <valItem ident="src_ОТ"/>
                        <valItem ident="src_ОЭ"/>
                        <valItem ident="src_ОЭп."/>
                        <valItem ident="src_ОЯФ I"/>
                        <valItem ident="src_%sPuškin%s. Arhau"/>
                        <valItem ident="src_Qazaq"/>
                        <valItem ident="src_%sQazb.%s"/>
                        <valItem ident="src_%sQirǧ.%s"/>
                        <valItem ident="src_%sSam.%s"/>
                        <valItem ident="src_SD"/>
                        <valItem ident="src_СД"/>
                        <valItem ident="src_%sСека%s"/>
                        <valItem ident="src_%sСека%s. Ир. фийау"/>
                        <valItem ident="src_Сл."/>
                        <valItem ident="src_СОПам."/>
                        <valItem ident="src_%sSozur%s"/>
                        <valItem ident="src_%sТайм.%s Ӕмдз."/>
                        <valItem ident="src_%sТайм.%s Мӕ зӕрд."/>
                        <valItem ident="src_%sTujǧ.%s"/>
                        <valItem ident="src_Хаджи-Мурат"/>
                        <valItem ident="src_%sХар.%s Кадӕг"/>
                        <valItem ident="src_%sXar.%s Zærdæ"/>
                        <valItem ident="src_Хрест."/>
                        <valItem ident="src_ЮОПам."/>
                        <valItem ident="src_Лука"/>
                        <valItem ident="src_Матфей"/>
                        <valItem ident="src_Марк"/>
                        <valItem ident="src_Иоанн"/>                        
                    </valList>
                </attDef>
            </attList>
        </elementSpec>-->
                <elementSpec ident="re" mode="change">
                    <content>
                        <alternate>
                            <sequence>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <elementRef key="form" minOccurs="1" maxOccurs="2"/>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/> <!-- additional forms -->
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <elementRef key="usg" minOccurs="0" maxOccurs="2"/>
                                <alternate minOccurs="0" maxOccurs="unbounded">
                                    <classRef key="model.global"/>
                                    <elementRef key="formGrp" minOccurs="0" maxOccurs="unbounded"/>
                                    <!-- additional forms after the sense -->
                                    <elementRef key="sense"/>
                                    <elementRef key="re"/>
                                </alternate>
                                <elementRef key="exampleGrp" minOccurs="0" maxOccurs="unbounded"/>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <elementRef key="re" minOccurs="0" maxOccurs="unbounded"/>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <!--                            <elementRef key="re" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
                                <!--                            <elementRef key="exampleGrp" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="etym" minOccurs="0" maxOccurs="2"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            <elementRef key="ref" minOccurs="0" maxOccurs="unbounded"/>
                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
                            </sequence>
                            <sequence><!-- several subentries with shared sense(s) -->
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <sequence minOccurs="2" maxOccurs="unbounded">
                                    <elementRef key="re" minOccurs="1" maxOccurs="unbounded"/>
                                    <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                </sequence>
                                <elementRef key="sense" minOccurs="0" maxOccurs="unbounded"/>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                <elementRef key="exampleGrp" minOccurs="0" maxOccurs="unbounded"/>
                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                            </sequence>
                        </alternate>
                    </content>
                </elementSpec>
            </schemaSpec></body></text></TEI>
